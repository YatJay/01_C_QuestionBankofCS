## 10_指针

### 一维数组指针

#### 注意事项

1. 定义形参以及传递参数时int num[]和int *num是等价的 ，甚至使用时也是等价的，可以将指针变量后跟[]作为数组引用
2. \*(pdata+i)取数组元素要加括号，先算地址，再取地址；如果不加，由于*的优先级更高，先算*pdata取内容值，再对该内容值+i 
3. 函数传入实参为数组首地址是一个地址常量，为方便使用，一般需要**先定义一个指针变量并赋值为实参数组首地址**



#### 一般算法

##### 使用指针循环遍历一维数组

```c
p=&a[0];	for(i=1;i<n;i++){	
    *(p+i);	
}
```

```c
for(p=&a[0];p<a+n;p++){	
    *p;	
}
```

##### S = 1/1! +1/2! +1/3! + … +1/N!函数

```c
void fun(double *sn, int n)
{
	int i;
	double Sum=0, jc=1;

	for (i=1; i<=n; i++){
		jc *= i;  //计算分母累乘的结果
		Sum += 1 / jc;  //计算分母累乘结果做分母累加
	}
	*sn=Sum;  //使用指针修改实参内容
}
```



### 二维数组指针

#### 注意事项：

##### 二维数组指针的理解(P784)：

1. 二维数组行指针可以当做二维数组名一样在遍历中使用

2. 理解二维数组的行指针： 
   *(p+1)+1表示第 1 行第 1 个元素(从第0行开始数，从第0列开始数)的地址。如何理解呢？
       *(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。
       \*(\*(p+1)+1)表示第 1 行第 1 个元素的值(从0开始计数)。很明显，增加一个 * 表示取地址上的数据。

3. 本题中使用的 \*(\*(ppscore+i)+j)运算过程 ： 
   	先计算 *(ppscore+i)得到的是第i行的首地址即第i行第0个元素地址；
   	再对该地址+j为 *(ppscore+i)+j表示本行第j个元素的地址；
   	再取 *(ppscore+i)+j 指向得内容值 \*(\*(ppscore+i)+j)即数组元素的值。 

##### 二维数组行指针(P804)

###### 行指针等价代换成二维数组名 (P804)

1. 二维数组名本身是一个行指针类型的指针 
2. int (*pStu)[7]定义一个行指针，每行7列 
3. 当函数接收的参数是一个二维数组行指针类型，使用时 直接把行指针等价代换成二维数组名
4. 可以只用指针进行二维数组操作 ，见下

###### 只用指针进行二维数组操作(P804改、P797)

1. **char (*p)[80]** 定义一个行指针变量
2. p+i是行指针，即指向的是一整行所有元素，若对它加1则指向下一行即指向n个元素
3. 由于*(p+i)是取整行的数据，使用时无意义，所以
   1. \*(p+i) 在表达式中指向本行的首元素，
   2. 从而 \*(p+i)+j可以指向这一行的各个元素，
   3. \*(\*(p+i)+j) 访问本行的各个元素
4. *(p+1) 在定义时或者和 sizeof、& 一起使用时才表示整个数组



### 字符串指针

#### 注意事项

##### 函数传递实参为地址

函数传入实参为字符数组首地址是一个地址常量，为方便使用，一般需要**先定义一个字符指针变量并赋值为实参字符数组首地址**

##### 函数返回值为指针注意事项：

​		函数返回指针必须返回主函数传进来的，函数内部定义的指针无法返回C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。

​		因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。

#### 一般算法

##### 使用**指针进行数组元素反转**的一般算法

```c
char *sp, *st, ch;
sp = str;  //记录字符数组首地址 
st = str + strlen(str) - 1;  //记录字符数组最后一个字符地址 
while (sp <= st)
{
    ch = *sp;  //sp指向的数组前端位置将被置换为数组尾元素，使用ch暂存 
    *sp = *st;  //sp指向的数组前端位置置换为数组尾元素 
    *st = ch;  //数组尾元素换成ch暂存的数组前端位置元素 
    sp++;  //数组前端指针后移 
    st--;  //数组后端指针前移 
}
```



##### 使用指针对两个数组进行顺序交叉合并的一般算法



##### 不使用 strcat()而只用指针进行字符串拼接：(P787)

1. 循环遍历到str1字符串尾，循环内不做任何操作，记录'\0'所在的地址 
2. 循环遍历str2，从'\0'所在的地址开始依次拼接 
3. 由于循环的条件是*(str2+i)!='\0'，所以循环结束后需要 *(strn+i)='\0'使得新字符串以'\0'结尾  





